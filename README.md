# ComponmentDemo
## 背景
随着Android APP业务需求的不断迭代，业务功能越来越多，代码量也越来越多，组件间难免会因为方法功能调用页面访问等场景存在相互访问依赖耦合。为此，探索一种可行方案彻底解决组件模块间耦合同时还能满足组件间相互通信访问显得十分必要。经过不断努力探索调研结合过去工作经验项目总结推出本方案。

## 本方案技术原理如下:
1.组件分两个部分，Module级的接口和对应接口实现Module，达到接口和实现类Module级别的隔离;

2.组件间依赖不在直接依赖实现类Module，而只需依赖其Module接口;

3.通过编译时注解标注具体接口实现类，编译时注解处理器Processor来写实现类class路径文件;

4.app启动运行时通过SPI技术ServiceLoader根据步骤3生成的配置文件将对应的接口和实现类Class作为key,value值注册进公共组件管理模块CmptServiceManager中，而该过程中公共组件是不需要依赖任何组件;

5.当组件a需要使用组件b提供能力时，只需通过公共组件管理类CmptServiceManager.getInstance().getComponmentService(IComponmentBService.class)方法就可以从组件管理模块中拿到组件b的实现类，从访问其接口实现;

6.同时通过定义的Module级接口传递参数，完成组件间通信;

## 本方案有以下特点:
1.解耦彻底，通过编译时注解和Java SPI技术向公共组件管理类中注册组件接口和组件实现类之间对应关系，在注册组件和使用组件时均不需要有业务组件依赖;

2.组件间通信使用简单性能高效，支持所有基本类型和类类型，像在调用Module内部接口一样

3.在main，NebulaIntegration等module多个APP各自维护，逻辑分散，维护成本增大。面向Module级接口编程可以使用一套代码，主逻辑基于接口开发，各自实现差异化，结合可配置方案配置实现类module是否参与编译，实现各自打包。

4.面向接口编程，实现类module升级变化，不会影响使用方，特别适合业务快速迭代场景

5.面向服务编程，每一个Module模块提供的是一种服务能力，通过接口对外暴露服务能力，能有效避免重复开发

6.相比市场上其他方案更加轻量级，没有占用更多cpu内存资源开销



## 系统交互图

